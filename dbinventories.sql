CREATE DATABASE DBINVENTORIES;
USE DBINVENTORIES;

CREATE TABLE INVENTORY (
	CODEINV INT AUTO_INCREMENT PRIMARY KEY NOT NULL,
    NAMEINV VARCHAR(128) NOT NULL DEFAULT "Inventario de la Farmacia",
    DESCRIPTIONINV VARCHAR(512) NOT NULL DEFAULT "Inventario General",
    UBICATIONINV VARCHAR(512) NOT NULL DEFAULT "Sucre - Bolivia",
    PHOTOINV VARCHAR(512) NOT NULL DEFAULT "inventory.webp",
    TOTALAMOUNT INT NOT NULL DEFAULT 0,
    TOTALVALUEINV FLOAT NOT NULL DEFAULT 0.0
) ENGINE = INNODB;

CREATE TABLE CATEGORY (
	CODECAT INT AUTO_INCREMENT PRIMARY KEY NOT NULL,
    NAMECAT VARCHAR(128) NOT NULL DEFAULT "Sin categoría"
) ENGINE = INNODB;

CREATE TABLE SUPPLIER (
	CODESUP INT AUTO_INCREMENT PRIMARY KEY NOT NULL,
    NAMESUP VARCHAR(128) NOT NULL DEFAULT ""
) ENGINE = INNODB;

CREATE TABLE BRAND (
    CODEBRAND INT AUTO_INCREMENT PRIMARY KEY NOT NULL,
    NAMEBRAND VARCHAR(128) NOT NULL DEFAULT ""
) ENGINE = INNODB;

CREATE TABLE PRODUCT (
	CODEPROD INT AUTO_INCREMENT PRIMARY KEY NOT NULL,
    NAMEEPROD VARCHAR(128) NOT NULL DEFAULT "",
    DESCRIPTIONPROD VARCHAR(256) NOT NULL DEFAULT "",
    TOTALAMOUNT INT NOT NULL DEFAULT 0,
    TOTALVALUE FLOAT DEFAULT 0.0,
    PHOTOPROD VARCHAR(512) NOT NULL DEFAULT "paquete.png",
    CODINV INT NOT NULL,
    CODCAT INT NOT NULL,
    CODSUP INT NOT NULL,
    CODEBRAND INT NOT NULL,
    FOREIGN KEY (CODINV) REFERENCES INVENTORY(CODEINV),
    FOREIGN KEY (CODCAT) REFERENCES CATEGORY(CODECAT),
    FOREIGN KEY (CODSUP) REFERENCES SUPPLIER(CODESUP),
    FOREIGN KEY (CODEBRAND) REFERENCES BRAND(CODEBRAND)
) ENGINE = INNODB;

CREATE TABLE ITEM (
	CODEITEM INT AUTO_INCREMENT PRIMARY KEY NOT NULL,
    LOTNUMBER INT NOT NULL,
    DESCRIPTIONITEM VARCHAR(256) NOT NULL DEFAULT "",
    OBSERVATION VARCHAR(128) NOT NULL DEFAULT "",
    DATEENTRY DATE NOT NULL DEFAULT CURRENT_DATE,
    DATEEXPIRATION DATE NOT NULL DEFAULT CURRENT_DATE,
    TOTALAMOUNT FLOAT NOT NULL DEFAULT 0.0,
    TOTALVALUE FLOAT DEFAULT 0.0,
    UNITPRICE FLOAT NOT NULL DEFAULT 0.0,
    CODPROD INT NOT NULL,
    FOREIGN KEY (CODPROD) REFERENCES PRODUCT(CODEPROD)
) ENGINE = INNODB;

CREATE TABLE HISTORYINVENTORY (
	CODEHISTORYINV INT AUTO_INCREMENT PRIMARY KEY NOT NULL,
    DATEQUERY DATE NOT NULL DEFAULT CURRENT_DATE,
    DETAIL VARCHAR(128) NOT NULL DEFAULT "",
    EXITDOCUMENT VARCHAR(32) NOT NULL DEFAULT "",
    ENTRYAMOUNT INT NOT NULL DEFAULT 0,
    OUTPUTAMOUNT INT NOT NULL DEFAULT 0,
    BALANCEEO INT NOT NULL DEFAULT 0,
    DEBIT FLOAT NOT NULL DEFAULT 0.0,
    CREDIT FLOAT NOT NULL DEFAULT 0.0,
    BALANCEDC FLOAT NOT NULL DEFAULT 0.0,
    CODINV INT NOT NULL,
    FOREIGN KEY (CODINV) REFERENCES INVENTORY(CODEINV)
) ENGINE = INNODB;

CREATE TABLE HISTORYPRODUCT (
	CODEHISTORYPROD INT AUTO_INCREMENT PRIMARY KEY NOT NULL,
    DATEQUERY DATE NOT NULL DEFAULT CURRENT_DATE,
    DETAIL VARCHAR(128) NOT NULL DEFAULT "",
    EXITDOCUMENT VARCHAR(32) NOT NULL DEFAULT "",
    ENTRYAMOUNT INT NOT NULL DEFAULT 0,
    OUTPUTAMOUNT INT NOT NULL DEFAULT 0,
    BALANCEEO INT NOT NULL DEFAULT 0,
    DEBIT FLOAT NOT NULL DEFAULT 0.0,
    CREDIT FLOAT NOT NULL DEFAULT 0.0,
    BALANCEDC FLOAT NOT NULL DEFAULT 0.0,
    CODPROD INT NOT NULL,
    FOREIGN KEY (CODPROD) REFERENCES PRODUCT(CODEPROD)
) ENGINE = INNODB;


-- MySQLTRIGGERS


DELIMITER //
    CREATE TRIGGER AFTERINSERTINVENTORY AFTER INSERT ON INVENTORY FOR EACH ROW
    BEGIN
        -- VACÍO, NO SE REQUIERE NADA DESPUÉS DE INSERTAR EN INVENTARIO
    END //;
DELIMITER ;

DELIMITER //
    CREATE TRIGGER BEFOREINSERTINVENTORY BEFORE INSERT ON INVENTORY FOR EACH ROW
    BEGIN
        IF NEW.TOTALAMOUNT < 0 OR NEW.TOTALVALUEINV < 0 THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'No se puede insertar un valor negativo';
        END IF;
        SET NEW.TOTALVALUEINV = 0.0;
        SET NEW.TOTALAMOUNT = 0;
    END //;
DELIMITER ;

DELIMITER //
    CREATE TRIGGER AFTERUPDATEINVENTORY AFTER UPDATE ON INVENTORY FOR EACH ROW
    BEGIN
        -- VACÍO, NO SE REQUIERE NADA DESPUÉS DE ACTUALIZAR EN INVENTARIO
    END //;
DELIMITER ;

DELIMITER //
    CREATE TRIGGER BEFOREUPDATEINVENTORY BEFORE UPDATE ON INVENTORY FOR EACH ROW
    BEGIN
        IF NEW.TOTALAMOUNT < 0 OR NEW.TOTALVALUEINV < 0 THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'No se puede insertar un valor negativo';
        END IF;
    END //;
DELIMITER ;

DELIMITER //
    CREATE TRIGGER AFTERDELETEINVENTORY AFTER DELETE ON INVENTORY FOR EACH ROW
    BEGIN
        DELETE FROM PRODUCT WHERE CODINV = OLD.CODEINV;
    END //;
DELIMITER ;

DELIMITER //
    CREATE TRIGGER BEFOREDELETEINVENTORY BEFORE DELETE ON INVENTORY FOR EACH ROW
    BEGIN
        IF OLD.TOTALAMOUNT > 0 THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'No se puede eliminar un inventario con productos';
        END IF;
    END //;
DELIMITER ;

DELIMITER //
    CREATE TRIGGER AFTERINSERTPRODUCT AFTER INSERT ON PRODUCT FOR EACH ROW
    BEGIN
        UPDATE INVENTORY SET TOTALAMOUNT = TOTALAMOUNT + NEW.TOTALAMOUNT, TOTALVALUEINV = TOTALVALUEINV + NEW.TOTALVALUE WHERE CODEINV = NEW.CODINV;
    END //;
DELIMITER ;

DELIMITER //
    CREATE TRIGGER BEFOREINSERTPRODUCT BEFORE INSERT ON PRODUCT FOR EACH ROW
    BEGIN
        IF NEW.TOTALAMOUNT < 0 OR NEW.TOTALVALUE < 0 THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'No se puede insertar un valor negativo';
        END IF;
        SET NEW.TOTALVALUE = 0.0;
        SET NEW.TOTALAMOUNT = 0;
    END //;
DELIMITER ;

DELIMITER //
    CREATE TRIGGER AFTERUPDATEPRODUCT AFTER UPDATE ON PRODUCT FOR EACH ROW
    BEGIN
        IF NEW.TOTALAMOUNT < OLD.TOTALAMOUNT THEN
            UPDATE INVENTORY SET TOTALAMOUNT = TOTALAMOUNT + NEW.TOTALAMOUNT - OLD.TOTALAMOUNT, TOTALVALUEINV = TOTALVALUEINV + NEW.TOTALVALUE - OLD.TOTALVALUE WHERE CODEINV = NEW.CODINV;
        ELSE
            UPDATE INVENTORY SET TOTALAMOUNT = TOTALAMOUNT - OLD.TOTALAMOUNT + NEW.TOTALAMOUNT, TOTALVALUEINV = TOTALVALUEINV - OLD.TOTALVALUE + NEW.TOTALVALUE WHERE CODEINV = NEW.CODINV;
        END IF;
    END //;
DELIMITER ;

DELIMITER //
    CREATE TRIGGER BEFOREUPDATEPRODUCT BEFORE UPDATE ON PRODUCT FOR EACH ROW
    BEGIN
        IF NEW.TOTALAMOUNT < 0 OR NEW.TOTALVALUE < 0 THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'No se puede insertar un valor negativo';
        END IF;
    END //;
DELIMITER ;

DELIMITER //
    CREATE TRIGGER AFTERDELETEPRODUCT AFTER DELETE ON PRODUCT FOR EACH ROW
    BEGIN
        UPDATE INVENTORY SET TOTALAMOUNT = TOTALAMOUNT - OLD.TOTALAMOUNT, TOTALVALUEINV = TOTALVALUEINV - OLD.TOTALVALUE WHERE CODEINV = OLD.CODINV;
        DELETE FROM ITEM WHERE CODPROD = OLD.CODEPROD;
    END //;
DELIMITER ;

DELIMITER //
    CREATE TRIGGER BEFOREDELETEPRODUCT BEFORE DELETE ON PRODUCT FOR EACH ROW
    BEGIN
        IF OLD.TOTALAMOUNT > 0 THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'No se puede eliminar un producto con items';
        END IF;
    END //;
DELIMITER ;

DELIMITER //
    CREATE TRIGGER AFTERINSERTITEM AFTER INSERT ON ITEM FOR EACH ROW
    BEGIN
        UPDATE PRODUCT SET TOTALAMOUNT = TOTALAMOUNT + NEW.TOTALAMOUNT, TOTALVALUE = TOTALVALUE + NEW.TOTALVALUE WHERE CODEPROD = NEW.CODPROD;
    END //;
DELIMITER ;

DELIMITER //
    CREATE TRIGGER BEFOREINSERTITEM BEFORE INSERT ON ITEM FOR EACH ROW
    BEGIN
        IF NEW.TOTALAMOUNT < 0 OR NEW.TOTALVALUE < 0 OR NEW.UNITPRICE < 0 THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'No se puede insertar un valor negativo';
        END IF;
        SET NEW.TOTALVALUE = 0.0;
        SET NEW.TOTALAMOUNT = 0;
    END //;
DELIMITER ;

DELIMITER //
    CREATE TRIGGER AFTERUPDATEITEM AFTER UPDATE ON ITEM FOR EACH ROW
    BEGIN
        IF NEW.TOTALAMOUNT < OLD.TOTALAMOUNT THEN
            UPDATE PRODUCT SET TOTALAMOUNT = TOTALAMOUNT + NEW.TOTALAMOUNT - OLD.TOTALAMOUNT, TOTALVALUE = TOTALVALUE + NEW.TOTALVALUE - OLD.TOTALVALUE WHERE CODEPROD = NEW.CODPROD;
        ELSE
            UPDATE PRODUCT SET TOTALAMOUNT = TOTALAMOUNT - OLD.TOTALAMOUNT + NEW.TOTALAMOUNT, TOTALVALUE = TOTALVALUE - OLD.TOTALVALUE + NEW.TOTALVALUE WHERE CODEPROD = NEW.CODPROD;
        END IF;
    END //;
DELIMITER ;

DELIMITER //
    CREATE TRIGGER BEFOREUPDATEITEM BEFORE UPDATE ON ITEM FOR EACH ROW
    BEGIN
        IF NEW.TOTALAMOUNT < 0 OR NEW.TOTALVALUE < 0 OR NEW.UNITPRICE < 0 THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'No se puede insertar un valor negativo';
        END IF;
        SET NEW.TOTALVALUE = NEW.TOTALAMOUNT * NEW.UNITPRICE;
    END //;
DELIMITER ;

DELIMITER //
    CREATE TRIGGER AFTERDELETEITEM AFTER DELETE ON ITEM FOR EACH ROW
    BEGIN
        UPDATE PRODUCT SET TOTALAMOUNT = TOTALAMOUNT - OLD.TOTALAMOUNT, TOTALVALUE = TOTALVALUE - OLD.TOTALVALUE WHERE CODEPROD = OLD.CODPROD;
    END //;
DELIMITER ;

DELIMITER //
    CREATE TRIGGER BEFOREDELETEITEM BEFORE DELETE ON ITEM FOR EACH ROW
    BEGIN
        IF OLD.TOTALAMOUNT > 0 THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'No se puede eliminar un item con cantidad mayor a 0';
        END IF;
    END //;
DELIMITER ;


-- MySQLPROCEDURES


DELIMITER //
    CREATE PROCEDURE INSERTINVENTORY(IN _NAMEINV VARCHAR(128), IN _DESCRIPTIONINV VARCHAR(512), IN _UBICATIONINV VARCHAR(512), IN _PHOTOINV VARCHAR(512))
    BEGIN
        INSERT INTO INVENTORY (NAMEINV, DESCRIPTIONINV, UBICATIONINV, PHOTOINV) VALUES (_NAMEINV, _DESCRIPTIONINV, _UBICATIONINV, _PHOTOINV);
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE UPDATEINVENTORY(IN _CODEINV INT, IN _NAMEINV VARCHAR(128), IN _DESCRIPTIONINV VARCHAR(512), IN _UBICATIONINV VARCHAR(512), IN _PHOTOINV VARCHAR(512))
    BEGIN
        UPDATE INVENTORY SET NAMEINV = _NAMEINV, DESCRIPTIONINV = _DESCRIPTIONINV, UBICATIONINV = _UBICATIONINV, PHOTOINV = _PHOTOINV WHERE CODEINV = _CODEINV;
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE DELETEINVENTORY(IN _CODEINV INT)
    BEGIN
        DELETE FROM INVENTORY WHERE CODEINV = _CODEINV;
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE INSERTCATEGORY(IN _NAMECAT VARCHAR(128))
    BEGIN
        INSERT INTO CATEGORY (NAMECAT) VALUES (_NAMECAT);
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE UPDATECATEGORY(IN _CODECAT INT, IN _NAMECAT VARCHAR(128))
    BEGIN
        UPDATE CATEGORY SET NAMECAT = _NAMECAT WHERE CODECAT = _CODECAT;
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE DELETECATEGORY(IN _CODECAT INT)
    BEGIN
        DELETE FROM CATEGORY WHERE CODECAT = _CODECAT;
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE INSERTSUPPLIER(IN _NAMESUP VARCHAR(128))
    BEGIN
        INSERT INTO SUPPLIER (NAMESUP) VALUES (_NAMESUP);
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE UPDATESUPPLIER(IN _CODESUP INT, IN _NAMESUP VARCHAR(128))
    BEGIN
        UPDATE SUPPLIER SET NAMESUP = _NAMESUP WHERE CODESUP = _CODESUP;
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE DELETESUPPLIER(IN _CODESUP INT)
    BEGIN
        DELETE FROM SUPPLIER WHERE CODESUP = _CODESUP;
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE INSERTBRAND(IN _NAMEBRAND VARCHAR(128))
    BEGIN
        INSERT INTO BRAND (NAMEBRAND) VALUES (_NAMEBRAND);
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE UPDATEBRAND(IN _CODEBRAND INT, IN _NAMEBRAND VARCHAR(128))
    BEGIN
        UPDATE BRAND SET NAMEBRAND = _NAMEBRAND WHERE CODEBRAND = _CODEBRAND;
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE DELETEBRAND(IN _CODEBRAND INT)
    BEGIN
        DELETE FROM BRAND WHERE CODEBRAND = _CODEBRAND;
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE INSERTPRODUCT(IN _NAMEPROD VARCHAR(128), IN _DESCRIPTIONPROD VARCHAR(256), IN _CODINV INT, IN _CODCAT INT, IN _CODSUP INT, IN _PHOTOPROD VARCHAR(512))
    BEGIN
        INSERT INTO PRODUCT (NAMEEPROD, DESCRIPTIONPROD, CODINV, CODCAT, CODSUP, PHOTOPROD) VALUES (_NAMEPROD, _DESCRIPTIONPROD, _CODINV, _CODCAT, _CODSUP, _PHOTOPROD);
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE UPDATEPRODUCT(IN _CODEPROD INT, IN _NAMEPROD VARCHAR(128), IN _DESCRIPTIONPROD VARCHAR(256), IN _CODINV INT, IN _CODCAT INT, IN _CODSUP INT, IN _PHOTOPROD VARCHAR(512))
    BEGIN
        UPDATE PRODUCT SET NAMEEPROD = _NAMEPROD, DESCRIPTIONPROD = _DESCRIPTIONPROD, CODINV = _CODINV, CODCAT = _CODCAT, CODSUP = _CODSUP, PHOTOPROD = _PHOTOPROD WHERE CODEPROD = _CODEPROD;
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE DELETEPRODUCT(IN _CODEPROD INT)
    BEGIN
        DELETE FROM PRODUCT WHERE CODEPROD = _CODEPROD;
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE INSERTITEM(IN _LOTNUMBER INT, IN _DESCRIPTIONITEM VARCHAR(256), IN _OBSERVATION VARCHAR(128), IN _DATEENTRY DATE, IN _DATEEXPIRATION DATE, IN _UNITPRICE FLOAT, IN _CODPROD INT)
    BEGIN
        INSERT INTO ITEM (LOTNUMBER, DESCRIPTIONITEM, OBSERVATION, DATEENTRY, DATEEXPIRATION, UNITPRICE, CODPROD) VALUES (_LOTNUMBER, _DESCRIPTIONITEM, _OBSERVATION, _DATEENTRY, _DATEEXPIRATION, _UNITPRICE, _CODPROD);
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE UPDATEITEM(IN _CODEITEM INT, IN _LOTNUMBER INT, IN _DESCRIPTIONITEM VARCHAR(256), IN _OBSERVATION VARCHAR(128), IN _DATEENTRY DATE, IN _DATEEXPIRATION DATE, IN _UNITPRICE FLOAT, IN _CODPROD INT)
    BEGIN
        UPDATE ITEM SET LOTNUMBER = _LOTNUMBER, DESCRIPTIONITEM = _DESCRIPTIONITEM, OBSERVATION = _OBSERVATION, DATEENTRY = _DATEENTRY, DATEEXPIRATION = _DATEEXPIRATION, UNITPRICE = _UNITPRICE, CODPROD = _CODPROD WHERE CODEITEM = _CODEITEM;
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE UPDATEQUANTITYITEM(IN _CODEITEM INT, IN _TOTALAMOUNT FLOAT)
    BEGIN
        UPDATE ITEM SET TOTALAMOUNT = _TOTALAMOUNT WHERE CODEITEM = _CODEITEM;
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE DELETEITEM(IN _CODEITEM INT)
    BEGIN
        DELETE FROM ITEM WHERE CODEITEM = _CODEITEM;
    END //;
DELIMITER ;

DELIMITER //
CREATE PROCEDURE CREATEHISTORYINVENTORY(
    IN _DETAIL VARCHAR(128), 
    IN _EXITDOCUMENT VARCHAR(32), 
    IN _CODINV INT
)
BEGIN
    DECLARE ENTRYAMOUNT_ INT DEFAULT 0;
    DECLARE OUTPUTAMOUNT_ INT DEFAULT 0;
    DECLARE DEBIT_ FLOAT DEFAULT 0.0;
    DECLARE CREDIT_ FLOAT DEFAULT 0.0;
    DECLARE BALANCEEOA_ INT DEFAULT 0;
    DECLARE BALANCEDCA_ FLOAT DEFAULT 0.0;
    DECLARE UNITCOST_ FLOAT DEFAULT 0.0;
    DECLARE TOTALVALUEINV_ FLOAT DEFAULT 0.0;
    DECLARE LASTENTRYAMOUNT_ INT DEFAULT 0;
    DECLARE COUNT_HISTORY INT DEFAULT 0;
    IF (SELECT COUNT(*) FROM INVENTORY WHERE CODEINV = _CODINV) = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'EL INVENTARIO NO EXISTE';
    END IF;
    SET COUNT_HISTORY = (SELECT COUNT(*) FROM HISTORYINVENTORY WHERE CODINV = _CODINV);
    SET ENTRYAMOUNT_ = (SELECT TOTALAMOUNT FROM INVENTORY WHERE CODEINV = _CODINV);
    SET TOTALVALUEINV_ = (SELECT TOTALVALUEINV FROM INVENTORY WHERE CODEINV = _CODINV);
    IF ENTRYAMOUNT_ > 0 THEN
        SET UNITCOST_ = TOTALVALUEINV_ / ENTRYAMOUNT_;
    ELSE
        SET UNITCOST_ = 0;
    END IF;
    IF COUNT_HISTORY = 0 THEN
        SET OUTPUTAMOUNT_ = 0;
        SET DEBIT_ = TOTALVALUEINV_;
        SET CREDIT_ = 0;
        SET BALANCEEOA_ = ENTRYAMOUNT_;
        SET BALANCEDCA_ = DEBIT_;
    ELSE
        SET LASTENTRYAMOUNT_ = (SELECT ENTRYAMOUNT FROM HISTORYINVENTORY WHERE CODINV = _CODINV ORDER BY CODEHISTORYINV DESC LIMIT 1);
        SET BALANCEEOA_ = (SELECT BALANCEEO FROM HISTORYINVENTORY WHERE CODINV = _CODINV ORDER BY CODEHISTORYINV DESC LIMIT 1);
        SET BALANCEDCA_ = (SELECT BALANCEDC FROM HISTORYINVENTORY WHERE CODINV = _CODINV ORDER BY CODEHISTORYINV DESC LIMIT 1);
        IF ENTRYAMOUNT_ = LASTENTRYAMOUNT_ THEN
            SET OUTPUTAMOUNT_ = 0;
            SET CREDIT_ = 0;
            SET DEBIT_ = 0;
        ELSEIF ENTRYAMOUNT_ < LASTENTRYAMOUNT_ THEN
            SET OUTPUTAMOUNT_ = LASTENTRYAMOUNT_ - ENTRYAMOUNT_;
            SET ENTRYAMOUNT_ = 0;
            SET CREDIT_ = OUTPUTAMOUNT_ * UNITCOST_;
            SET DEBIT_ = 0;
        ELSE
            SET OUTPUTAMOUNT_ = 0;
            SET CREDIT_ = 0;
            SET DEBIT_ = (ENTRYAMOUNT_ - LASTENTRYAMOUNT_) * UNITCOST_;
        END IF;
        SET BALANCEEOA_ = BALANCEEOA_ + ENTRYAMOUNT_ - OUTPUTAMOUNT_;
        SET BALANCEDCA_ = BALANCEDCA_ + DEBIT_ - CREDIT_;
    END IF;
    INSERT INTO HISTORYINVENTORY (
        DATEQUERY, 
        DETAIL, 
        EXITDOCUMENT, 
        ENTRYAMOUNT, 
        OUTPUTAMOUNT, 
        BALANCEEO, 
        DEBIT, 
        CREDIT, 
        BALANCEDC, 
        CODINV
    ) 
    VALUES (
        CURRENT_DATE, 
        _DETAIL, 
        _EXITDOCUMENT, 
        ENTRYAMOUNT_, 
        OUTPUTAMOUNT_, 
        BALANCEEOA_, 
        DEBIT_, 
        CREDIT_, 
        BALANCEDCA_, 
        _CODINV
    );
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE CREATEHISTORYPRODUCT(
    IN _DETAIL VARCHAR(128), 
    IN _EXITDOCUMENT VARCHAR(32), 
    IN _CODPROD INT
)
BEGIN
    DECLARE ENTRYAMOUNT_ INT DEFAULT 0;
    DECLARE OUTPUTAMOUNT_ INT DEFAULT 0;
    DECLARE DEBIT_ FLOAT DEFAULT 0.0;
    DECLARE CREDIT_ FLOAT DEFAULT 0.0;
    DECLARE BALANCEEOA_ INT DEFAULT 0;
    DECLARE BALANCEDCA_ FLOAT DEFAULT 0.0;
    DECLARE UNITCOST_ FLOAT DEFAULT 0.0;
    DECLARE TOTALVALUEPROD_ FLOAT DEFAULT 0.0;
    DECLARE LASTENTRYAMOUNT_ INT DEFAULT 0;
    DECLARE COUNT_HISTORY INT DEFAULT 0;
    IF (SELECT COUNT(*) FROM PRODUCT WHERE CODEPROD = _CODPROD) = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'El producto no existe';
    END IF;
    SET COUNT_HISTORY = (SELECT COUNT(*) FROM HISTORYPRODUCT WHERE CODPROD = _CODPROD);
    SET ENTRYAMOUNT_ = (SELECT TOTALAMOUNT FROM PRODUCT WHERE CODEPROD = _CODPROD);
    SET TOTALVALUEPROD_ = (SELECT TOTALVALUEINV FROM PRODUCT WHERE CODEPROD = _CODPROD);
    IF ENTRYAMOUNT_ > 0 THEN
        SET UNITCOST_ = TOTALVALUEPROD_ / ENTRYAMOUNT_;
    ELSE
        SET UNITCOST_ = 0;
    END IF;
    IF COUNT_HISTORY = 0 THEN
        SET OUTPUTAMOUNT_ = 0;
        SET DEBIT_ = TOTALVALUEPROD_;
        SET CREDIT_ = 0;
        SET BALANCEEOA_ = ENTRYAMOUNT_;
        SET BALANCEDCA_ = DEBIT_;
    ELSE
        SET LASTENTRYAMOUNT_ = (SELECT ENTRYAMOUNT FROM HISTORYPRODUCT WHERE CODPROD = _CODPROD ORDER BY CODEHISTORYPROD DESC LIMIT 1);
        SET BALANCEEOA_ = (SELECT BALANCEEO FROM HISTORYPRODUCT WHERE CODPROD = _CODPROD ORDER BY CODEHISTORYPROD DESC LIMIT 1);
        SET BALANCEDCA_ = (SELECT BALANCEDC FROM HISTORYPRODUCT WHERE CODPROD = _CODPROD ORDER BY CODEHISTORYPROD DESC LIMIT 1);
        IF ENTRYAMOUNT_ = LASTENTRYAMOUNT_ THEN
            SET OUTPUTAMOUNT_ = 0;
            SET CREDIT_ = 0;
            SET DEBIT_ = 0;
        ELSEIF ENTRYAMOUNT_ < LASTENTRYAMOUNT_ THEN
            SET OUTPUTAMOUNT_ = LASTENTRYAMOUNT_ - ENTRYAMOUNT_;
            SET ENTRYAMOUNT_ = 0;
            SET CREDIT_ = OUTPUTAMOUNT_ * UNITCOST_;
            SET DEBIT_ = 0;
        ELSE
            SET OUTPUTAMOUNT_ = 0;
            SET CREDIT_ = 0;
            SET DEBIT_ = (ENTRYAMOUNT_ - LASTENTRYAMOUNT_) * UNITCOST_;
        END IF;
        SET BALANCEEOA_ = BALANCEEOA_ + ENTRYAMOUNT_ - OUTPUTAMOUNT_;
        SET BALANCEDCA_ = BALANCEDCA_ + DEBIT_ - CREDIT_;
    END IF;
    INSERT INTO HISTORYPRODUCT (
        DATEQUERY, 
        DETAIL, 
        EXITDOCUMENT, 
        ENTRYAMOUNT, 
        OUTPUTAMOUNT, 
        BALANCEEO, 
        DEBIT, 
        CREDIT, 
        BALANCEDC, 
        CODPROD
    ) 
    VALUES (
        CURRENT_DATE, 
        _DETAIL, 
        _EXITDOCUMENT, 
        ENTRYAMOUNT_, 
        OUTPUTAMOUNT_, 
        BALANCEEOA_, 
        DEBIT_, 
        CREDIT_, 
        BALANCEDCA_, 
        _CODPROD
    );
END //
DELIMITER ;


DELIMITER //
    CREATE PROCEDURE GETALLTABLES ()
    BEGIN
        SHOW TABLES;
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE GETALLCOLUMNS (IN _TABLENAME VARCHAR(128))
    BEGIN
        SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = _TABLENAME;
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE GETALLCOLUMNSNAME (IN _TABLENAME VARCHAR(128))
    BEGIN
        SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = _TABLENAME;
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE GETALLVIEWS ()
    BEGIN
        SHOW FULL TABLES WHERE TABLE_TYPE = 'VIEW';
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE GETALLFUNCTIONS ()
    BEGIN
        SHOW FUNCTION STATUS WHERE Db = 'DBINVENTORIES';
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE GETALLPROCEDURES ()
    BEGIN
        SHOW PROCEDURE STATUS WHERE Db = 'DBINVENTORIES';
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE GETALLARGUMENTSPROCEDURE (IN _PROCEDURENAME VARCHAR(128))
    BEGIN
        SELECT PARAMETER_NAME FROM INFORMATION_SCHEMA.PARAMETERS WHERE SPECIFIC_NAME = _PROCEDURENAME;
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE GETALLARGUMENTSFUNCTION (IN _FUNCTIONNAME VARCHAR(128))
    BEGIN
        SELECT PARAMETER_NAME FROM INFORMATION_SCHEMA.PARAMETERS WHERE SPECIFIC_NAME = _FUNCTIONNAME;
    END //;
DELIMITER ;

DELIMITER //
CREATE PROCEDURE SEARCHINVENTORYBYPATTERN (IN _PATTERN VARCHAR(128), IN _COLUMN VARCHAR(128))
BEGIN
    SELECT * FROM INVENTORY WHERE _COLUMN LIKE CONCAT('%', _PATTERN, '%');
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE SEARCHPRODUCTBYPATTERN (IN _PATTERN VARCHAR(128), IN _COLUMN VARCHAR(128))
BEGIN
    SELECT P.*, C.NAMECAT, S.NAMESUP FROM PRODUCT P JOIN CATEGORY C ON P.CODCAT = C.CODECAT JOIN SUPPLIER S ON P.CODSUP = S.CODESUP WHERE _COLUMN LIKE CONCAT('%', _PATTERN, '%');                     
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE SEARCHITEMBYPATTERN (IN _PATTERN VARCHAR(128), IN _COLUMN VARCHAR(128))
BEGIN
    SELECT * FROM ITEM WHERE _COLUMN LIKE CONCAT('%', _PATTERN, '%');
END //
DELIMITER ;

-- PROCEDURE PARA DEVOLVER LOS ID DE LOS PRODUCTOS QUE CONTIENEN ITEMS EXPIRADOS DADOS UN INVENTARIO.

DELIMITER //
    CREATE PROCEDURE GETALLIDEXPIRATEDITEMSBYINVENTORY (IN _CODEINV INT)
    BEGIN
        SELECT I.CODEITEM FROM ITEM I JOIN PRODUCT P ON I.CODPROD = P.CODEPROD WHERE I.DATEEXPIRATION < CURRENT_DATE AND P.CODINV = _CODEINV;
    END //;
DELIMITER ;

-- HACER UN JOIN DE PRODUCTO CON INVENTARIO, CATEGORÍA Y PROVEEDOR

DELIMITER //
    CREATE PROCEDURE GETALLIDEXPIRATEDITEMSBYPRODUCT (IN _CODPROD INT)
    BEGIN
        SELECT I.CODEITEM FROM ITEM I JOIN PRODUCT P ON I.CODPROD = P.CODEPROD WHERE I.DATEEXPIRATION < CURRENT_DATE AND P.CODEPROD = _CODPROD;
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE GETALLIDPRODEXPIRATEDITEMSBYPRODUCT (IN _CODPROD INT)
    BEGIN
        SELECT P.CODEPROD FROM ITEM I JOIN PRODUCT P ON I.CODPROD = P.CODEPROD WHERE I.DATEEXPIRATION < CURRENT_DATE AND P.CODEPROD = _CODPROD;
    END //;
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE GETALLIDPRODEXPIRATEDITEMSBYPRODUCTDISTINCT (IN _CODPROD INT)
    BEGIN
        SELECT DISTINCT P.CODEPROD FROM ITEM I JOIN PRODUCT P ON I.CODPROD = P.CODEPROD WHERE I.DATEEXPIRATION < CURRENT_DATE AND P.CODEPROD = _CODPROD;
    END //
DELIMITER ;

DELIMITER //
    CREATE PROCEDURE GETALLIDPRODEXPIRATEDITEMSBYINVENTORY(IN _CODINV INT)
    BEGIN
        SELECT P.CODEPROD FROM ITEM I JOIN PRODUCT P ON I.CODPROD = P.CODEPROD WHERE I.DATEEXPIRATION < CURRENT_DATE AND P.CODINV = _CODINV;
    END //;
DELIMITER ;

-- MySQLVIEWS

CREATE VIEW VIEWINVENTORY AS 
SELECT * 
FROM INVENTORY 
ORDER BY TOTALVALUEINV DESC;

CREATE VIEW VIEWCATEGORY AS 
SELECT * 
FROM CATEGORY;

CREATE VIEW VIEWSUPPLIER AS 
SELECT * 
FROM SUPPLIER;

CREATE VIEW VIEWBRAND AS
SELECT *
FROM BRAND;

CREATE VIEW VIEWPRODUCT AS 
SELECT * 
FROM PRODUCT 
ORDER BY TOTALVALUE DESC;

CREATE VIEW VIEWITEM AS 
SELECT * 
FROM ITEM 
ORDER BY TOTALVALUE DESC;

CREATE VIEW VIEWHISTORYINVENTORY AS 
SELECT * 
FROM HISTORYINVENTORY;

CREATE VIEW VIEWHISTORYPRODUCT AS 
SELECT * 
FROM HISTORYPRODUCT;

CREATE VIEW PRODUCTBYINVENTORY AS 
SELECT * 
FROM PRODUCT 
WHERE CODINV = (SELECT CODEINV FROM INVENTORY WHERE INVENTORY.CODEINV = PRODUCT.CODINV) 
ORDER BY TOTALVALUE DESC;

CREATE VIEW ITEMBYPRODUCT AS 
SELECT * 
FROM ITEM 
WHERE CODPROD = (SELECT CODEPROD FROM PRODUCT WHERE PRODUCT.CODEPROD = ITEM.CODPROD) 
ORDER BY TOTALVALUE DESC;

CREATE VIEW HISTORYINVENTORYBYINVENTORY AS 
SELECT * 
FROM HISTORYINVENTORY 
WHERE CODINV = (SELECT CODEINV FROM INVENTORY WHERE INVENTORY.CODEINV = HISTORYINVENTORY.CODINV);

CREATE VIEW HISTORYPRODUCTBYPRODUCT AS 
SELECT * 
FROM HISTORYPRODUCT 
WHERE CODPROD = (SELECT CODEPROD FROM PRODUCT WHERE PRODUCT.CODEPROD = HISTORYPRODUCT.CODPROD);

CREATE VIEW PRODUCTBYINVENTORYFULL AS 
SELECT 
    PRODUCT.CODEPROD, 
    PRODUCT.NAMEEPROD, 
    PRODUCT.DESCRIPTIONPROD, 
    PRODUCT.TOTALAMOUNT, 
    PRODUCT.TOTALVALUE, 
    PRODUCT.PHOTOPROD, 
    CATEGORY.NAMECAT, 
    SUPPLIER.NAMESUP,
    BRAND.NAMEBRAND,
    PRODUCT.CODINV
FROM 
    PRODUCT 
JOIN 
    INVENTORY ON PRODUCT.CODINV = INVENTORY.CODEINV 
JOIN 
    CATEGORY ON PRODUCT.CODCAT = CATEGORY.CODECAT 
JOIN 
    SUPPLIER ON PRODUCT.CODSUP = SUPPLIER.CODESUP
JOIN
    BRAND ON PRODUCT.CODEBRAND = BRAND.CODEBRAND 
ORDER BY 
    PRODUCT.TOTALVALUE DESC;


-- MySQLFUNCTIONS

DELIMITER //
    CREATE FUNCTION GETALLITEMSEXPIRATESBYPRODUCT(_CODPROD INT) RETURNS INT
    BEGIN
        DECLARE TOTAL INT;
        SELECT COUNT(*) INTO TOTAL FROM ITEM WHERE CODPROD = _CODPROD AND DATEEXPIRATION < CURRENT_DATE;
        RETURN TOTAL;
    END //;
DELIMITER ;

DELIMITER //
    CREATE FUNCTION GETALLIDITEMSEXPIRATESBYPRODUCT(_CODPROD INT) RETURNS INT
    BEGIN
        DECLARE TOTAL INT;
        SELECT CODEITEM INTO TOTAL FROM ITEM WHERE CODPROD = _CODPROD AND DATEEXPIRATION < CURRENT_DATE;
        RETURN TOTAL;
    END //;
DELIMITER ;

DELIMITER //
    CREATE FUNCTION GETALLITEMSEXPIRATESBYPRODUCTANDDATE(_CODPROD INT, _DATEEXPIRATION DATE) RETURNS INT
    BEGIN
        DECLARE TOTAL INT;
        SELECT COUNT(*) INTO TOTAL FROM ITEM WHERE CODPROD = _CODPROD AND DATEEXPIRATION < _DATEEXPIRATION;
        RETURN TOTAL;
    END //;
DELIMITER ;

DELIMITER //
    CREATE FUNCTION GETQUANTITYITEMSEXPIRATESBYPRODUCT(_CODPROD INT) RETURNS INT
    BEGIN
        DECLARE TOTAL INT;
        SELECT SUM(TOTALAMOUNT) INTO TOTAL FROM ITEM WHERE CODPROD = _CODPROD AND DATEEXPIRATION < CURRENT_DATE;
        RETURN TOTAL;
    END //;
DELIMITER ;

DELIMITER //
    CREATE FUNCTION GETQUANTITYITEMSEXPIRATESBYINVENTORY(_CODINV INT) RETURNS INT
    BEGIN
        DECLARE TOTAL INT;
        SELECT SUM(I.TOTALAMOUNT) INTO TOTAL FROM ITEM I JOIN PRODUCT P ON I.CODPROD = P.CODEPROD WHERE P.CODINV = _CODINV AND I.DATEEXPIRATION < CURRENT_DATE;
        RETURN TOTAL;
    END //;
DELIMITER ;
